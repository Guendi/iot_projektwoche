<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<title>Rolf Keller, Bit f&uuml;r Bit</title>
<meta name="author" content="mk">
<meta name="generator" content="Ulli Meybohms HTML EDITOR">
<link rel="stylesheet" type="text/css" href="../../../../style.css">
<link rel="apple-touch-icon" href="http://www.hsg-kl.de/apple-touch-icon.png?v=zXXQrJ6ozr">
<link rel="icon" type="image/png" href="http://www.hsg-kl.de/favicon-32x32.png?v=zXXQrJ6ozr">
<link rel="icon" type="image/png" href="http://www.hsg-kl.de/favicon-16x16.png?v=zXXQrJ6ozr">
<link rel="manifest" href="http://www.hsg-kl.de/manifest.json?v=zXXQrJ6ozr">
<link rel="mask-icon" href="http://www.hsg-kl.de/safari-pinned-tab.svg?v=zXXQrJ6ozr">
<link rel="shortcut icon" href="../../../../favicon.ico?v=zXXQrJ6ozr">
</head>
<body>
<div id="rahmen">
<div id="thWrapper">		<!-- Seiteninhalt-->
	<table cellspacing="0" cellpadding="8" border="0">
		<tr style="background: #081B45">
			<td style="text-align: center;"><a href="http://www.hsg-kl.de/index.php"> <img src="../../../../logo_inv.jpg" alt=" " style="vertical-align: middle"></a></td>
			<td style="background: #081B45 url(../../../../banner2.jpg) ; width:100%"></td>
		</tr>
		<tr>
		 <td valign="top" style="font-size:24pt;text-align:center">HSG</td>
		 <td>
		    <table cellspacing="0" cellpadding="0" border="0" width="100%">
		      <tr>
		        <td valign="top">
				    <div id="nav"><ul id="thMenu">
<li><a href="http://www.hsg-kl.de/faecher/inf/netze/material/index.php">Material </a></li>
<li><a href="http://www.hsg-kl.de/faecher/inf/netze/history/index.php">historische Beispiele </a></li>
<li><a href="http://www.hsg-kl.de/faecher/inf/netze/einstieg/index.php">Einstieg </a></li>
<li><a href="http://www.hsg-kl.de/faecher/inf/netze/grund/index.php">Grundbegriffe </a></li>
<li><a href="http://www.hsg-kl.de/faecher/inf/netze/netzHW/index.php">Netzhardware </a></li>
<li><a href="http://www.hsg-kl.de/faecher/inf/netze/raw/index.php">Raw-Transceiver </a></li>
<li><a href="http://www.hsg-kl.de/faecher/inf/netze/send/index.php">mini-Sender </a></li>
<li><a href="http://www.hsg-kl.de/faecher/inf/netze/empf/index.php">mini-Empf&auml;nger </a></li>
<li><a href="http://www.hsg-kl.de/faecher/inf/netze/mininet/index.php">miniEthernet </a></li>
<li><a href="http://www.hsg-kl.de/faecher/inf/netze/transceiver/index.php">Transceiver </a></li>
<li><a href="http://www.hsg-kl.de/faecher/inf/netze/fehler1/index.php">Fehlererkennung </a></li>
<li><a href="http://www.hsg-kl.de/faecher/inf/netze/fehler2/index.php">Fehlerbehandlung </a></li>
<li><a href="http://www.hsg-kl.de/faecher/inf/netze/bus/index.php">Bus </a></li>
<li><a href="http://www.hsg-kl.de/faecher/inf/netze/rahmen/index.php">Rahmen </a></li>
<li><a href="http://www.hsg-kl.de/faecher/inf/netze/mac/index.php">Medium Access Control </a></li>
<li><a href="http://www.hsg-kl.de/faecher/inf/netze/routing/index.php">Routing </a></li>
<li><a href="http://www.hsg-kl.de/faecher/inf/netze/schicht/index.php">Schichtenmodell </a></li>
<li><a href="http://www.hsg-kl.de/faecher/inf/netze/socket/index.php">Sockets </a></li>
<li><a href="http://www.hsg-kl.de/faecher/inf/netze/dienste/index.php">Dienste im Internet </a></li>
<li><a href="http://www.hsg-kl.de/faecher/inf/netze/filius/index.php">Filius </a></li>
<li><a href="http://www.hsg-kl.de/faecher/inf/netze/real/index.php">Real-Experimente </a></li>
<li><a href="http://www.hsg-kl.de/faecher/inf/netze/sicher/index.php">Sicherheit </a></li>
<li><a href="http://www.hsg-kl.de/faecher/inf/netze/code/index.php">Codes </a></li>
<li><a href="http://www.hsg-kl.de/faecher/inf/netze/programme/index.php">Programme </a></li>
<li><a href="http://www.hsg-kl.de/faecher/inf/netze/serial/index.php">Hardware </a></li>
<li><a href="http://www.hsg-kl.de/faecher/inf/netze/protokoll/index.php">Protokolle </a></li>
<li><a href="http://www.hsg-kl.de/faecher/inf/netze/glossar/index.php">Glossar </a></li>
<li><a href="http://www.hsg-kl.de/faecher/inf/netze/bauen/index.php">Bautipps </a></li>
<li><a href="http://www.hsg-kl.de/faecher/inf/netze/modem/index.php">Modem </a></li>
<li><a href="http://www.hsg-kl.de/faecher/inf/netze/lehrplan/index.php">Lehrplan </a></li>
<li><a href="http://www.hsg-kl.de/faecher/inf/netze/unterricht/index.php">Unterricht </a></li>
</ul></div>	<!-- restliche Menuzeilen -->	   	
				    <br>
				     <span style="font-size:10pt;">Aktuelle Seite:</span> 
				     <span id="thPath"><span><a href="http://www.hsg-kl.de/">HSG</a></span><span class="thSep">/</span><span><a href="http://www.hsg-kl.de/faecher">F&auml;cher</a></span><span class="thSep">/</span><span><a href="http://www.hsg-kl.de/faecher/inf">Informatik</a></span><span class="thSep">/</span><span><a href="http://www.hsg-kl.de/faecher/inf/netze">Netze</a></span></span>		    
			     </td>
			     <td valign="top" align="right" style="width:200px">
			     <form action="http://www.google.com/cse" id="cse-search-box">
 					 <div>
  					  <input type="hidden" name="cx" value="011847682886435709016:b5le6wv1cpe">
  					  <input type="hidden" name="ie" value="ISO-8859-1">
 					  <input type="text" name="q" size="15">
 					  <input type="submit" name="sa" value="Suche">
				   </div>
				 </form>
    			  <script type="text/javascript" src="http://www.google.com/coop/cse/brand?form=cse-search-box&amp;lang=de"></script><br>
    			  <!-- <span id="thMainTitle"></span> --><!-- Erste Zeile Menudatei -->
    		   </td>
		   </tr>			   
		  </table>			     
		  </td>
		</tr>
   </table>
	<div id="thContent">
<h1>Bit f&uuml;r Bit</h1> Serielle Schnittstelle, Rolf Keller, c't 1983, Heft 12, S.82ff&nbsp;&nbsp;
 (Ver&ouml;ffentlichung mit freundlicher Genehmigung der c't)<br><br>
Die verschiedenen Komponenten eines Computersystems verkehren miteinander &uuml;ber Schnittstellen. Selbstverst&auml;ndlich m&uuml;ssen bestimmte Konventionen eingehalten werden, damit die Datenkommunikation reibungslos ablaufen kann. Dieser c't-Grundlagenbeitrag zeigt, worauf es beim Einsatz serieller Schnittstellen ankommt.

<h3>Die TTY-Schnittstelle</h3>
Geht man von dem Zeitbegriff der heutigen schnellebigen Mikroelektronik aus, so kann man die TTY-Schnittstelle schon fast als vorgeschichtlich bezeichnen. Sie ist n&auml;mlich schon mehr als 100(!) Jahre alt. Urspr&uuml;nglich wurde sie f&uuml;r das Fernschreibnetz entwickelt (TTY = Teletype = Fernschreiber).
Beide Stationen werden in Form eines geschlossenen Stromkreises miteinander verbunden (siehe Bild 1),<img src="bild1.gif">  wobei im Ruhezustand ein konstanter Gleichstrom von z.B. 20mA flie&szlig;t. Daher wird die TTY-Schnittstelle oft nach als '20-mA-Stromschnittstelle' bezeichnet. Die &Uuml;bertragung von Daten geschieht nun einfach so, da&szlig; der Sender den Schleifenstrom in einem bestimmten Rhythmus unterbricht. Beim altgedienten Fernschreiber geschieht dies durch einen mecha-nischen Unterbrecherkontakt. Der Empf&auml;nger erkennt die rhythmischen Unterbrechungen mit Hilfe einer Art Relaisspule und setzt sie wieder in mechanische Bewegung um. Man beachte, da&szlig; mit einer nur 2-adrigen Leitung ohne irgendeine Umschaltung in beide Richtungen ge-arbeitet werden kann. Allerdings geht dies nicht gleichzeitig: einer der beiden Sender mu&szlig; stets in Ruhestellung sein (Unterbrecherkontakt geschlossen). Diese Art des eingeschr&auml;nkten Zweirichtungsbetriebs nennt man Halbduplexverfahren. F&uuml;r einen echten Zweirichtungsbetrieb (Vollduplex) ben&ouml;tigt man getrennte Stromschleifen f&uuml;r Senden und Empfang.
Wird die TTY-Schnittstelle bei Computerperipherieger&auml;ten benutzt, so verwendet man nat&uuml;rlich moderne Halbleiterbauelemente: der Unterbrecherkontakt wird durch einen Schalttransistor ersetzt, die Empfangsspule durch einen Optokoppler (siehe Bild 2).<img src="bild2.gif">  Man unterscheidet zwischen aktiven und passiven TTY-Schnittstellen. Eine aktive Schnittstelle enth&auml;lt eine Quelle f&uuml;r den Schleifenstrom, eine passive dagegen nicht. In Bild 2 ist der Sender aktiv, der Empf&auml;nger passiv. Normalerweise sollten immer eine passive mit einer aktiven Schnittstelle zusammen eine Stromschleife bilden.
<h3>Das serielle Datenformat</h3>
Wie sieht nun der oben beschriebene Rhythmus der Stromunterbrechungen w&auml;hrend der Daten&uuml;bertragung aus? Auf der Leitung liegt zu jedem Zeitpunkt nur ein Bit (siehe Bild 3).<img src="bild3.gif">  Die einzelnen, zu einem Zeichen geh&ouml;renden Bits werden der Reihe nach ('seriell') gesendet. Jedem zu sendenden Zeichen wird ein START-Bit (log. 0) vorangestellt. Danach folgen die Bits des Zeichens selbst (z. B. sieben Bit des ASCII-Codes). Als Abschlu&szlig; folgt das Parit&auml;tsbit (siehe unten) und ein bis zwei STOP-Bits (log. 1), worauf die Leitung wieder im Ruhezustand ist.
Logikpegel, Leitungspegel und die zugeh&ouml;rigen englischen Bezeichnungen sind in Tabelle 1<img src="tabelle1.gif"> dargestellt. Jedes Bit liegt f&uuml;r die gleiche, feste Zeitspanne auf der Leitung. Sie wird angegeben in der Einheit 'Baud' (nach Baudot, einem Pionier der Fernschreibertechnik), wobei gilt: 1 Baud = 1 Bit pro Sekunde. Damit ist die Geschwindigkeit der Daten&uuml;bertragung jedoch noch nicht festgelegt, denn zwischen den einzelnen Zeichen kann die Leitung ja beliebig lange im Ruhezustand verharren.
Die maximale Datenrate ergibt sich, wenn die einzelnen Zeichen so dicht aufeinanderfolgen, da&szlig; das START-Bit eines Zeichens direkt an das letzte STOP-Bit des vorangehenden Zeichens angrenzt. Bei der &Uuml;bertragung von 7-Bit-ASCII-Zeichen mit je einem START-, Parit&auml;ts- und STOP-Bit ergibt sich beispielsweise bei einer Baudrate von 300 Baud eine maximal erreichbare Datenrate von 300/(7+3) = 3O Zeichen pro Sekunde.

<h3>Sender und Empf&auml;nger: stillschweigende &Uuml;bereinkunft</h3>
Das zuvor beschriebene Datenformat la&szlig;t dem Sender verschiedene M&ouml;glichkeiten offen: unterschiedliche Baudraten sind m&ouml;glich; die Anzahl der STOP-Bits kann variieren; das Parit&auml;tsbit kann vorhanden sein oder fehlen; schlie&szlig;lich gibt es verschiedene Codes f&uuml;r die Daten selbst (ASCII, EBCDI und andere). Der Empf&auml;nger kann nur dann erfolgreich arbeiten, wenn er das vom Sender verwendete Datenformat 'kennt'.
Obwohl man theoretisch durch Beobachtung eines l&auml;ngeren Datenstroms das Format herausfinden kann, wird doch in der Regel so verfahren, da&szlig; Sender und Empf&auml;nger jeder f&uuml;r sich per Hardware (z. B. DIL-Schalter) oder per Software auf das gleiche Datenformat eingestellt werden. Sie verstehen sich dann von selbst in stillschweigender &Uuml;bereinkunft.
<h3>&Uuml;bereinstimmende Baudraten: ein Problem</h3>
Um eine vorgegebene Baudrate zu erreichen, wird gew&ouml;hnlich sowohl im Sender wie im Empf&auml;nger mit einem Oszillator eine feste Bezugsfrequenz erzeugt. Es kann nicht ausbleiben, da&szlig; sich die Bezugsfrequenzen (und somit die effektiven Baudraten) von Sender und Empf&auml;nger um ein Weniges voneinander unterscheiden. Bei einer Abweichung von 1 Promille w&uuml;rden Sender und Empf&auml;nger nach 1000 Bits um 1 Bit 'auseinandergelaufen' sein. Der Empf&auml;nger w&uuml;rde dann v&ouml;llig falsche Daten empfangen.
Um dies.. Problem zu umgehen, werden START- und STOP-Bits verwendet. Der Empf&auml;nger synchronisiert sich selbst zu Beginn jedes Zeichens neu. Ist die Leitung im Ruhezustand, so beobachtet er sie, bis er irgendwann die Anfangsflanke (von log. 1 nach log. 0) eines START-Bits erkennt. Diesen Zeitpunkt benutzt er als Anfangsmarke und fragt nun die Leitung f&uuml;r jedes erwartete Bit des laufenden Zeichens einmal ab. Die Zeitpunkte der Abfrage legt der Empf&auml;nger dabei so, da&szlig; sie in die Mitte der einzelnen Bits fallen. Das Datenbit 0 wird also 1,5 Bitzeiten nach der Anfangsflanke des START-Bits abgefragt, das Datenbit 1 2,5 Bitzeiten nach der Anfangsflanke des START-Bits und so weiter ...
Beim Erreichen des STOP-Bits beginnt der Empf&auml;nger wieder frei zu laufen und wartet auf das n&auml;chste START-Bit. Hier zeigt sich die Notwendigkeit eines STOP-Bits. Falls das letzte Bit eines Zeichens log. 0 ist, konnte der Empf&auml;nger es nicht von dem eventuell unmittelbar folgenden START-Bit des n&auml;chsten Zeichens unterscheiden. Daher mu&szlig; jedem START-Bit (log. 1) stets ein entgegengesetzter Pegel (log. 1) vorangehen. Dieser wird von einem STOP-Bit geliefert. Da die Leitung im Ruhezustand denselben Pegel hat (siehe Tabelle 1),  funktioniert dieses Verfahren auch nach l&auml;ngeren &Uuml;bertragungspausen. Es garantiert die korrekte Funktion auch bei nicht exakt &uuml;bereinstimmenden Bandraten und bei den auf der Leitung unvermeidlich auftretenden Phasenfehlern und Kurvenformverzerrungen, (wegen der Abfrage in Bit-Mitte). Da der Empf&auml;nger stets nur f&uuml;r die Dauer eines Zeichens ann&auml;hernd synchron zum Sender l&auml;uft und diesen Synchronismus am Ende jedes Zeichens wieder aufgibt, bezeichnet man dieses &Uuml;bertragungsverfahren als Asynchronbetrieb. Der ebenfalls m&ouml;gliche Synchronbetrieb hat im PersonaIcomputerbereich bisher keine Bedeutung, er wird daher hier nicht weiter behandelt.
Die STOP-Bits haben neben der eben geschilderten manchmal noch eine weitere Funktion: Sie geben dem Empf&auml;ngerger&auml;t etwas Zeit, um das gerade empfangene Zeichen zu verarbeiten (zum Beispiel zu drucken). Aus diesem Grunde werden bisweilen 1,5 oder 2 STOP-Bits verwendet; man erh&ouml;ht so diese Reservezeit etwas. Nat&uuml;rlich gibt es in der Digitaltechnik nicht 1,5 Bits; die Angabe soll hier bedeuten, da&szlig; das STOP-Bit 1,5 Bit-Zeiten lang ist.
<h3>Kontrolle statt Vertrauen: Parit&auml;tsbit</h3>
Wie schon erw&auml;hnt, kann zus&auml;tzlich zu den Datenbits noch ein Parit&auml;tsbit &uuml;bertragen werden. Dieses Bit erm&ouml;glicht eine primitive Fehlerkontrolle. Wird mit gerader Parit&auml;t gearbeitet, so setzt der Sender das Parit&auml;tsbit auf log. 1, falls das zu sendende Zeichen eine ungerade Anzahl von gesetzten (log.1) Bits enth&auml;lt. Bei einer geraden Anzahl wird das Parit&auml;tsbit auf log. 0 gesetzt. Der Empf&auml;nger pr&uuml;ft nun nach der gleichen Vorschrift, ob das Parit&auml;tsbit zu den Datenbits 'pa&szlig;t'. Falls bei der &Uuml;bertragung eines der Datenbits verf&auml;lscht worden ist, so ist dies also vom Empf&auml;nger erkennbar. Nicht erkennbar ist jedoch, welches das verf&auml;lschte Bit ist. Ist eine gerade Anzahl von Bits verf&auml;lscht, so bleibt dies unerkannt.
Die verschiedenen M&ouml;glichkeiten, ein Parit&auml;tsbit zu senden, sind in Tabelle 2 <img src="tabelle2.gif"> dargestellt. Beim Empf&auml;nger ist es meist m&ouml;glich, die Parit&auml;tspr&uuml;fung auszuschalten. Dennoch mu&szlig; der Empf&auml;nger in jedem Fall das Vorhandensein des Parit&auml;tsbits ber&uuml;cksichtigen, da es ja jedes Zeichen um ein Bit verl&auml;ngert Um das STOP-Bit zum richtigen Zeitpunkt erwarten zu k&ouml;nnen, mu&szlig; also der Empf&auml;nger stets nach einer der M&ouml;glichkeiten von Tabelle 2 passend zum Sender eingestellt sein. Ob das empfangene Parit&auml;tsbit aber gepr&uuml;ft wird, ist eine andere Sache.
Eine weitere Pr&uuml;fungsm&ouml;glichkeit bietet das STOP-Bit. Liegt es nicht auf log. 1, so betrachtet der Empf&auml;nger dies als 'frame error' (engl. frame = Rahmen, gemeint ist de, Rahmen, den START- und STOP-Bit mit die Datenbits bilden).
<h3>RS-232-C: eine moderne serielle Schnittstelle</h3>
Diese moderne Form der seriellen Schnittstelle ist unter verschiedenen Namen bekannt: CCITT V.24, EIARS-232-C, DIN 66020. Exakt gleich sind diese Normen jedoch nicht. Die RS-232-C-Schnittstelle wurde urspr&uuml;nglich in der Gro&szlig;computerei verwendet, um Rechner und Terminals an ein Modem anzuschlie&szlig;en (Bild 4).<img src="bild4.gif">  Auf diese Weise werden z.B. die Terminals in einem Reiseb&uuml;ro mit dem entfernten Zentralrechner verbunden.
Man beachte in Bild 4, da&szlig; die RS232-C-Verbindung nur das kurze St&uuml;ck zwischen Rechner beziehungsweise Terminal und Moden bildet, nicht die eigentliche Fern&uuml;bertragungstrecke. F&uuml;r diese Anwendung wurden die genannten Normen konzipiert. Sie definieren deshalb mehr als 20 Adern pro Leitung mit vielen Sonderfunktionen.
In der Mikrocomputerei werden RS232-C-Verbindungen in der Regel zum Anschlu&szlig; von Peripherieger&auml;ten (zum Beispiel Bildschirmterminal oder Drucker) an einen Rechner benutzt. Modems sind dabei nicht beteiligt. Daher entf&auml;llt ein Gro&szlig;teil der in den Normen vorgesehenen Signaladern. Die in der Mikrocomputerei verwendeten Signale sind in Tabelle 3 <img src="tabelle3.gif"> zusammengestellt. Physikalisch ist die RS-232-C:Schnittstelle eine Spannungsschnittstelle (im Gegensatz zur TTY-Stromschnittstelle); f&uuml;r jede Richtung ist eine Signalader erforderlich, dazu kommt eine gemeinsame Masseleitung. Halbduplexbetrieb in der Form wie bei der TTY-Schnittstelle (siehe Bild 1) ist nicht m&ouml;glich. Als normgerechte Steckverbindung verwendet man den 25pol. Subminiatur-D-Stecker.
F&uuml;r das serielle Datenformat auf der Leitung (Pro 2 u. 3) gilt alles oben aber die TTY-Schnittstelle Gesagte. Die genormten Spannungspegel sind Tabelle 1 zu entnehmen. Die &uuml;brigen Signalleitungen (Pin 4, 5, 6 u. 20) werden als Handshake-Signale etc. benutzt. Sie arbeiten mit denselben Signalpegeln wie die Datenleitungen (Pin 2 u 3).
Wie aus Tabelle 3 zu erkennen, gibt es zwei unterschiedliche RS-232-CSchnittstellen: die Modemschnittstelle und die Terminalschnittstelle. Ein Ger&auml;t mit einer Modemschnittstelle kann man Pin f&uuml;r Pin mit einem Ger&auml;t mit Terminalschnittstelle verbunden. Beispielsweise ist Pin 2 bei der Terminalschnittstelle der Ausgang f&uuml;r die seriellen Daten, bei der Modemschnittstelle ist Pin 2 der zugeh&ouml;rige Eingang. In der Regel besitzt ein Personalcomputer eine Modemschnittstelle, die anzuschlie&szlig;enden Peripherieger&auml;te dagegen eine Terminalschnittstelle.
Will man zwei Ger&auml;te mit gleichnamigen Schnittstellen verbinden, so m&uuml;ssen im Kabel die Adern innerhalb der Leitungspaare 2,3 sowie 4,5 und 6,20 gekreuzt werden. Ein solches Kabel wird als Nullmodemkabel bezeichnet. Stets mu&szlig; ja ein Ausgangspin des einen Ger&auml;ts auf einen Eingangspin des anderen Ger&auml;ts treffen (Tabelle 3).
<h3>Serielle Interfacebausteine: hilfreich</h3>
Prinzipiell kann man das serielle Datenformat (Bild 3) allein mittels Software erzeugen, indem man ein Ausgangsbit eines Ports mit Hilfe von Verz&ouml;gerungsschleifen zu den richtigen Zeitpunkten auf 0 oder 1 setzt. Der Datenempfang per Software ist schon etwas schwieriger zu bew&auml;ltigen In der Praxis verwendet nan meist einen seriellen Interfacebaustein, UART (Universal Asynchronous Receiver and Transmitter = universeller asynchoner Empf&auml;nger und Sender) genannt.
Ein solcher Baustein wird an den Rechnerbus angeschlossen und 'unterh&auml;lt' sich mit der CPU in 8-Bit-paralleler Weise. Die Umwandlung parallel-seriell und umgekehrt sowie das Einf&uuml;gen von START-, STOP- und Parit&auml;tsbits geschehen automatisch im UART. Die gew&uuml;nschte Betriebsart des UART wird je nach Typ und Schaltung durch Hardware (zum Beispiel DIL-Schalter) oder Software eingestellt.
Zus&auml;tzlich zum UART sind noch Pegelwandler erforderlich, die die 5 V-Logik-Pegel des UART in die Leitungspegel (TTY oder RS-232C) umsetzen und umgekehrt. Au&szlig;erdem mu&szlig; der UART eine Bezugsfrequenz f&uuml;r die Baudrate (zum Beispiel in einem Quarzoszillator erzeugt) zugef&uuml;hrt werden.
<h3>&Uuml;bertragungsprozeduren</h3>
Bisher wurde nur beschrieben, wie eine Folge von Zeichen hintereinander seriell &uuml;bertragen werden kann. Nicht jedes Ger&auml;t ist aber zu jedem Zeitpunkt zum Empfang von Daten bereit. Sendet der Sender, w&auml;hrend der Empf&auml;nger nicht bereit ist, so gehen Daten verloren. Ein Drucker kann beispielsweise die Zeichen einer Zeile bei 9600 Baud in einer Zeit von 80msec empfangen und in seinen eingebautem Puffer ablegen. F&uuml;r den Druck der Zelle ben&ouml;tigter aber 800msec. Der Puffer w&uuml;rde also bald &uuml;berlaufen, wenn der Sender nicht zwischendurch &Uuml;bertragungspausen einlegte. Dies wird erreicht durch eine geeignete &Uuml;bertragungsprozedur.
Daf&uuml;r gibt es grunds&auml;tzlich zwei M&ouml;glichkeiten: R&uuml;ckkanal und Handshake. Bei Verwendung des R&uuml;ckkanals kann der Empf&auml;nger im VoIlduplexverfahren in der Gegenrichtung dem Sender mitteilen, ob momentan gesendet werden darf. Hierzu werden bestimmte Steuerzeichen vereinbart, z. B. XON und XOFF, die aber den R&uuml;ckkanal als Daten gesendet werden. Dieses Verfahren arbeitet ganz und gar auf Softwarebasis.
Bei Verwendung der Handshakesignale (bei der TTY-Schnittstelle nicht vorhanden) werden Sende- und Empfangsbereitschaft als Einzelbitsignale &uuml;ber zus&auml;tzliche Leitungsadern &uuml;bertragen. Dieses Verfahren kann sowohl durch Software als auch durch Hardware realisiert werden.
<h3>Praktischer Anschlu&szlig;: ein Problem f&uuml;r sich</h3>
Die Aufgabe, zwei Ger&auml;te mit seriellen Schnittstellen miteinander zu verbinden, erfordert oft einigen Arbeitsaufwand. Auf dem Markt findet man eine Vielfalt von unterschiedlichen Schnittstellen mit mangelhafter Dokumentation, die alle als &#130;voll normgerecht' deklariert sind. Mit Sicherheit verlassen kann man sich eigentlich nur auf das serielle Datenformat (Bild 3) und auf die Leitungspegel (Tabelle 1). Insbesondere bei Steckerbelegungen und &Uuml;bertragungsprozeduren gibt es viele ungenormte Variationen.
Vor dem eigentlichen Anschlie&szlig;en sollte man sich soviel Information wie m&ouml;glich beschaffen: durch Sichten aller greifbaren Unterlagen, durch Studieren der Ger&auml;te und zuletzt durch Probieren. Das probeweise Zusammenschalten ohne genaue Kenntnis der Pinbelegungen birgt aber Gefahren: treffen zwei aktive TTY-Schnittstellen oder zwei RS-232-C-Ausg&auml;nge aufeinander, so kann dies zu Defekten f&uuml;hren.
Grunds&auml;tzlich m&uuml;ssen sowohl Hardware als auch Software ber&uuml;cksichtigt werden. Aber auch hier ist Mi&szlig;trauen geboten: Hat beispielsweise ein Rechner eine RS232-CSchntttstelle mit allen Handshakesignalen nach Tabelle 3, so kann es dennoch m&ouml;glich sein, da&szlig; die im ROM vorhandenen Treiberprogramme f&uuml;r die Schnittstelle weder den R&uuml;ckkanal noch irgendein Handshakesignal benutzen.
<h3>Generell empfiehlt sich ein Vorgehen in vier Schritten:</h3>

<table>
<tr>
<td valign="top">1.</td>
 <td>Einstellen von Bandrate, Parit&auml;tsbit, STOP-Bits. Niedrige Bandraten sind f&uuml;r erste Versuche
     empfehlenswert ; mehr STOP-Bits beim Sender als beim Empf&auml;nger schaden nichts.</td>
</tr>
<tr>
<td valign="top">2.</td>
 <td>Verbindung der Ger&auml;te nur f&uuml;r eine Signalrichtung, zum Beispiel vom Rechner zum Drucker.
     Zun&auml;chst Weglassen aller Leitungen f&uuml;r Handshake und R&uuml;ckkanal.</td>
</tr>
<tr>
<td valign="top">3.</td>
 <td>Inbetriebnahme dieser Verbindung, wenn n&ouml;tig Korrektur von 1.</td>
</tr>
<tr>
<td valign="top">4.</td>
 <td>Nachdem einzelne Zeichen korrekt &uuml;bertragen werden k&ouml;nnen, vervollst&auml;ndigt man die
     Verbindung mit den zus&auml;tzlichen Adern f&uuml;r R&uuml;ckkanal und/oder Handshake. Bei einigen Ger&auml;ten
     ist schon nach Punkt 3. eine zufriedenstellende Arbeitsweise erreicht. Bei anderen Ger&auml;ten
     gen&uuml;gt ein, Geschwindigkeitsdrosselung durch Herabsetzen der Baudrate, um ohne besondere
     &Uuml;bertragungsprozedur auszukommen.</td>
</tr>
</table>
</div>		<!-- inhalt der Datei index.php -->
	<div id="footer">
		<table cellspacing="0" cellpadding="0" width="100%" summary="Dateiinfo">
					<tr>
						<td align="left" valign="bottom">
						   <span style="font-size:8pt">
								Autor: <span id="thAuthor">mk</span><br>
								Letzte &Auml;nderung dieser Seite: <span id="thChange">01.06.2003 15:26:50</span>, Seitenaufrufe: <span id="thCounter">38811</span>
							</span>
						</td>
					</tr>
		</table>	
	</div>
</div>
</div>
</body>
</html>
